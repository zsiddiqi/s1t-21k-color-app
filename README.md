# SpringOne Tour 2021 Lab

Compatible with [SpringOne Tour 2021 - Workshop 2](https://github.com/springone-tour-2021/lab-workshop-2)

You would need a kubernetes cluster as a pre-requisite.

## 2: Workshop Environment

### Command Execution

This workshop uses action blocks for various purposes. Any time you see such a block with an icon in the top right corner, you can click on it and it will perform the specified action for you.

This is a real environment where action blocks can create real apps and Kubernetes clusters. Please wait for an action to fully execute before proceeding to the next so the workshop behaves as expected.

### Terminals

Two terminals are included in this workshop, you will mainly use terminal 1, but if it's busy you can use terminal 2.

Try the action blocks below.

`echo "Hi I'm terminal 1"`

`echo "Hi I'm terminal 2"`

### Code Editor

The workshop features a built-in code editor you can use by pressing the _Editor_ tab button. The files in this editor save automatically.

Select the Editor tab now to display it, or click on the action block below.

> The editor takes a few moments to load. Pressing the refresh button in the workshop's UI can help the editor load when switching tabs.

### Kubernetes Console (Octant)

You will have the ability to inspect your Kubernetes cluster with Octant, an Open Source developer-centric web interface for Kubernetes that lets you inspect a Kubernetes cluster and its applications.

You haven't deployed anything to Kubernetes so there isn't much to display at the moment, but you can take a quick look at the dashboard now and come back to it later in the workshop.

Click the following action block to return to the Terminal.

## 3: App Overview

### The Color Application

Throughout this workshop, you will be using an application that displays colors. Each time the end user refreshes the page in a browser, a different color is displayed.

The application comprises the following Spring Boot apps:

- Auth Gateway App - Intercepts all requests and ensures the user is authenticated; if the user is not authenticated, it redirects the request to a login page.

- Routing Gateway App - Intercepts all authenticated requests and forwards them to the proper Spring Boot app; requests generated by end users are forwarded to the Frontend app, while requests generated by the Frontend app (JavaScript) are forwarded to a Backend app.
- Frontend App - Produces the HTML and JavaScript that will be served to the end user.
- Backend App - Returns a particular color; four instances of this app will be started: blue, green, "slow" green, and yellow.

The application also leverages a Discovery Server (based on Netflix Eureka) so that the apps can find one another's endpoints, as well as a Config Server to serve each app its respective configuration from a central location (the _config-files_ directory in the same code repository).

### Download The Source Code

Start by cloning the application:

`git clone -b 1.0 https://github.com/springone-tour-2021/color-app.git`

Navigate into the cloned directory in both terminal windows.

`cd color-app`

List the directories in the repository.

`ls -ld */`

Your output will show a directory per app listed above, as well as a config-files directory with configuration files for all apps. Compare the directory listing to the application overview above (hint: blueorgreengateway is the Routing Gateway and blueorgreenservice is the Backend service).

```
drwxr-xr-x 4 eduk8s root 4096 May  5 03:17 authgateway/
drwxr-xr-x 4 eduk8s root 4096 May  5 03:17 blueorgreenfrontend/
drwxr-xr-x 4 eduk8s root 4096 May  5 03:17 blueorgreengateway/
drwxr-xr-x 5 eduk8s root 4096 May  5 05:16 blueorgreenservice/
drwxr-xr-x 2 eduk8s root 4096 May  5 03:17 config-files/
```

### Next Steps

You are ready to begin the first lab of this workshop: run the application locally.

## 4: Lab 1 - Run Locally

Over the following few sections, you will run the application in the workshop terminal to see the application in action, including:

- Start Config And Discovery Servers
- Start Backend Apps
- Start Frontend and Gateway Apps
- Test The Application
- Understand The Application Behavior
- Shut Down The Application

## 5: Start Config And Discovery Servers

The applications are configured to connect to a Spring Cloud Config Server and a Eureka Discovery Server running locally in order to retrieve their configuration and find one another.

Use the **Spring Cloud CLI** to start an instance of each.

> Note: The following startup commands will run the Java processes in the background, so you won't see the app startup log appear in the terminal window. Instead, any logging will be redirected to a file.

`mkdir -p logs`

`spring cloud configserver eureka > logs/run-spring-cloud.log 2>&1 </dev/null &`

Run the following command repeatedly until you see output confirming that Config Server and Eureka have started.

> Note: To see the whole log, you can delete the second portion of the command, starting with the pipe character ("|").

`cat logs/run-spring-cloud.log | grep "started on port"`

The output should look like this, indicating Config Server listening on port 8888 and Eureka listening on port 8761.

```
2021-05-07 01:18:19.153  INFO 4779 --- [       Thread-0] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8888 (http) with context path ''
2021-05-07 01:18:27.420  INFO 4779 --- [       Thread-5] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8761 (http) with context path ''
```

Once Eureka has started, you can access its dashboard.

> Note: Leave the Eureka dashboard open in your browser. You will refer back to it in the following steps.

http://eduk8s-labs-w01-s076-eureka.s1tour-prod-c9040c6.tanzu-labs.esp.vmware.com/

## 6: Start Backend Apps

Start The 'blue' Instance
Next, build and start a Backend app instance using the blue profile.

> Note: In this workshop environment, we are choosing to use java -jar rather than mvn spring-boot:run to start the apps locally so that we can control the memory utilization.

```
cd blueorgreenservice && \
   ./mvnw package -DskipTests \
        > ../logs/build-blueorgreen.log 2>&1 </dev/null && \
   java -Xmx128M -Dspring.profiles.active=blue \
        -jar target/blueorgreen-0.0.1-SNAPSHOT.jar \
        > ../logs/run-blue.log 2>&1 </dev/null &
```

Run the following command repeatedly until you see a line of output confirming that the blue instance has started.

`cat logs/run-blue.log | grep "started on port"`

The output should look like this.

```
2021-04-20 21:58:43.563  INFO 798 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8181 (http) with context path ''
```

As you can see in the log output, blue started on port 8181.

Send a request to the blue app.

`http -b :8181`

The response will look like this.

```
{
    "id": "blue"
}
```

> Refresh the Eureka dashboard in your browser until you see that the blue app has registered itself. It uses the application name BLUEORGREEN.

Picture for reference of the blue app registered in Eureka Server:alt_text

### Start The Remaining Backend Instances

Start three more Backend instances: green, slowgreen, and yellow. The profiles are configured such that each will run on a different port to prevent conflicts on the same host.

```
cd blueorgreenservice && \
   java -Xmx128M -Dspring.profiles.active=green \
        -jar target/blueorgreen-0.0.1-SNAPSHOT.jar \
        > ../logs/run-green.log 2>&1 </dev/null &

cd blueorgreenservice && \
   java -Xmx128M -Dspring.profiles.active=slowgreen \
        -jar target/blueorgreen-0.0.1-SNAPSHOT.jar \
        > ../logs/run-slowgreen.log 2>&1 </dev/null &

cd blueorgreenservice && \
   java -Xmx128M -Dspring.profiles.active=yellow \
        -jar target/blueorgreen-0.0.1-SNAPSHOT.jar \
        > ../logs/run-yellow.log 2>&1 </dev/null &
```

Refresh the Eureka dashboard again until you see all four Backend instances registered. You should see an Application named **BLUEORGREEN** with four endpoints under the **Status** column, each with a unique port number.

> Picture for reference of Backend apps registered in Eureka Server:alt_text

Send a request to slowgreen. Notice that it takes 5 seconds to return.

`time http :6060`

## 7: Start Frontend and Gateway Apps

Start the Frontend, the Routing Gateway, and the Auth Gateway.

```
cd blueorgreenfrontend && \
   ./mvnw package -DskipTests \
        > ../logs/build-frontend.log 2>&1 </dev/null && \
   java -Xmx128M -Dspring.profiles.active=local \
        -jar target/blueorgreenfrontend-0.0.1-SNAPSHOT.jar \
        > ../logs/run-frontend.log 2>&1 </dev/null &

cd blueorgreengateway && \
   ./mvnw package -DskipTests \
        > ../logs/build-gateway.log 2>&1 </dev/null && \
   java -Xmx128M \
        -jar target/blueorgreengateway-0.0.1-SNAPSHOT.jar \
        > ../logs/run-gateway.log 2>&1 </dev/null &

cd authgateway && \
   ./mvnw package -DskipTests \
        > ../logs/build-authgateway.log 2>&1 </dev/null && \
   java -Xmx128M \
        -jar target/authgateway-0.0.1-SNAPSHOT.jar \
        > ../logs/run-authgateway.log 2>&1 </dev/null &
```

Make sure you see build and run logs being created for these three apps. You can use the cat command as before to see the contents of any file.

`ls -l logs/`

The output should look like this:

```
-rw-r--r-- 1 eduk8s root  59027 May 11 18:08 build-authgateway.log
-rw-r--r-- 1 eduk8s root 118665 May 11 18:06 build-blueorgreen.log
-rw-r--r-- 1 eduk8s root   2236 May 11 18:07 build-frontend.log
-rw-r--r-- 1 eduk8s root 130307 May 11 18:08 build-gateway.log
-rw-r--r-- 1 eduk8s root   8823 May 11 18:08 run-authgateway.log
-rw-r--r-- 1 eduk8s root   6539 May 11 18:06 run-blue.log
-rw-r--r-- 1 eduk8s root   6347 May 11 18:08 run-frontend.log
-rw-r--r-- 1 eduk8s root   8402 May 11 18:08 run-gateway.log
-rw-r--r-- 1 eduk8s root   6113 May 11 18:06 run-green.log
-rw-r--r-- 1 eduk8s root   6550 May 11 18:07 run-slowgreen.log
-rw-r--r-- 1 eduk8s root 165452 May 11 18:10 run-spring-cloud.log
-rw-r--r-- 1 eduk8s root   6115 May 11 18:06 run-yellow.log
```

Refresh the Eureka dashboard again until you see all apps registered. You should see four distinct application names in the Application column.

> Picture for reference of all apps registered in Eureka Server:alt_text

## 8: Test The Color Application

Test the application by opening the Auth Gateway endpoint in the browser.

http://eduk8s-labs-w01-s076-authgateway.s1tour-prod-c9040c6.tanzu-labs.esp.vmware.com/

Notice that you are automatically routed to a login page.

Log in using username **user** and password **pw**.

After logging in, refresh the page several times. You should see the color rotate between blue, green, and red. You should not see yellow.

Where is the red coming from? Notice that green never takes 5 seconds to appear. Instead, each time slowgreen is called, the color red appears after only a 1-second delay.

Log out of the application by typing **/logout** at the end of the URL or by clicking on the following action block:

http://eduk8s-labs-w01-s076-authgateway.s1tour-prod-c9040c6.tanzu-labs.esp.vmware.com/logout

Log in again using username **premium** and password **pw**. Refresh the page several times. You should now see yellow amongst the colors.

## 9: Understand Color Application Behavior

### Authentication & Authorization

Since this is a local deployment, the apps are reachable at their **host:port** address. However, the intention is that, in a production environment, you would expose only the Auth Gateway publically, and the rest of the apps would only be reachable internally.

The Auth Gateway uses Spring Cloud Security to apply a security filter, redirecting the user to a login page if the user has not yet been authenticated. Typically, the Auth Gateway would be integrated with an Identity Management system. However, to keep things simple in this demo app, credentials for two users (**user/pw** and **premium/pw**) are hard-coded in the Auth Gateway. Once a user has successfully authenticated, the Auth Gateway enriches the request headers with authorization information (aka **premium** or **nonpremium**) and forwards requests to the Routing Gateway. The Routing Gateway then routes requests to the remaining applications.

### Circuit Breaker And Fallback Configuration

The Routing Gateway will wait about one second for a color service instance to return. If it does not receive a response, it times out and resorts to a fallback action, which returns a hard-coded value of **red**.

Take a look at the code that defines this behavior.

`.filters(this::circuitBreaker)`

Look down the page to see the **circuitBreaker** method that configures the fallback, and even further down to see the **fallbackColor** method that returns **red**.

## 10: Understand Color Application Behavior, Continued

### Externalized Configuration

Upon startup, each app communicates with the Config Server to obtain its respective configuration. The Config Server retrieves all configuration files from the **config-files** [directory on GitHub](https://github.com/springone-tour-2021/color-app/tree/master/config-files). How does the Config Server know where to get the full set of config files? You can see this in the Config Server's properties file:

`uri`

The Config Server then uses each app's spring.application.name and its profile (e.g. blue) to filter the appropriate set of configuration parameters for a given app instance. For example, for the blue app, spring.application.name=blueorgreen and profiles=blue, so the configuration is created using an overlay of the following files: config-files/application.yml and parts of config-files/blueorgreen.yml. You can peruse the files locally since they are included in the cloned repo. Use the left-hand frame in the Editor to switch between files.

`blue`

## 11: Understand Color Application Behavior, Continued

### Service Discovery & Premium Configuration

For app-to-app communication, when an app needs to make an HTTP request to another app it uses Eureka to look up the endpoint of the destination app.

When the Routing Gateway looks up the Backend instances, it also checks for extra metadata. Specifically, it checks for metadata indicating if the service is **premium** or **nonpremium**. Take a look at the **blueorgreen.yml** that should be open in your Editor from the previous action block. Notice the default configuration property at the top of the file: `eureka.instance.metadataMap.hint: nonpremium`. Also notice that the yellow instance sets the value to premium.

You can verify that this metadata gets registered in Eureka using the following command, which retrieves details on all instances, and then filters the results using the key word **premium**. Notice that only the instance running on port 8282 (yellow) contains metadata containing the **premium** key word.

`http -b :8761/eureka/apps | grep -B 2 -A 2 "<hint>premium</hint>"`

Your output will look like this.

```
      <metadata>
        <instanceId>blueorgreen:8282</instanceId>
        <hint>premium</hint>
        <management.port>8282</management.port>
      </metadata>
```

The Routing Gateway uses the authorization information in the request header (added by the Auth Gateway) together with this metadata obtained from Eureka to determine whether to include the yellow endpoint in the load balancing for a given request user.

## 12: Shut Down The Applications

Stop all the locally running applications.

`kill $(pidof java)`

### Summary

In the previous exercise, you deployed and tested the Color Application locally at your terminal.

You should now have a good understanding of how the app works and of the expected behavior.

### Next Steps

You are ready to begin the second lab of this workshop: deploy the application to Kubernetes.

## 13: Lab 2 - Deploy To Kubernetes

The Color Application represents a "heritage" application - an existing application that is presumably running in production and is satisfying business needs. However, managing the application at scale on traditional infrastructure can be cumbersome. The company is modernizing infrastructure, and operational benefit can be gained from running the application on Kubernetes.

Over the following few sections, you will move the Color Application to Kubernetes. You will deploy only the four Color Application apps to Kubernetes, but not Eureka or Config Server.

- Add Spring Cloud Kubernetes
- Refactor Premium Service Routing
- Build Container Images
- Publish Images To Registry
- Inspect Images (OPTIONAL)
- Create Deployment Manifests
- Mount Configuration - Frontend and Gateway Apps
- Mount Configuration - Backend
- Add Liveness & Readiness Probes
- Template The Backend Deployment
- Create Service Manifests
- Create An Ingress For The Auth Gateway
- Deploy And Test The Applications

## 14: Spring Cloud Kubernetes

For the Kubernetes deployment, you will not make use of a standalone Spring Cloud Config Server or a Eureka Discovery Server. Instead, you will use Spring Boot support for ConfigMaps, and you will use Spring Cloud Kubernetes to resolve service names and load balance requests.

### Add Spring Cloud Kubernetes

Spring Cloud Kubernetes is a great way to bridge some of the differences between Spring Cloud and Kubernetes without having to make changes to your code.

Add Spring Cloud Kubernetes starters for discovery and load balancing to the pom.xml files for the Auth Gateway, Routing Gateway, and Frontend. You do not need to add it to the Backend app because the Backend app does not make requests to any other app.

> authgateway/pom.xml

```
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-kubernetes-client</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-kubernetes-client-loadbalancer</artifactId>
</dependency>
```

> blueorgreengateway/pom.xml

```
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-kubernetes-client</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-kubernetes-client-loadbalancer</artifactId>
</dependency>
```

> blueorgreenfrontend/pom.xml

```
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-kubernetes-client</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-kubernetes-client-loadbalancer</artifactId>
</dependency>
```

### Preserve Backwards Compatibility

To preserve local functionality with Eureka and Config Server and also support Kubernetes integration, you can use configuration to enable or disable Spring Cloud Kubernetes, as appropriate. The following commands will add the necessary enable/disable configuration to the **application.yml** files for all of our apps.

In the common **application.yml** that is shared by all of the apps, disable Spring Cloud Kubernetes by default. This will preserve the original behavior when the app is run locally.

> config-files/application.yml

```
cloud:
  kubernetes:
    discovery:
      enabled: false
    enabled: false
```

In the same file, add a second YAML document to enable Spring Cloud Kubernetes for Kubernetes deployments and disable Spring Cloud Config client. We can do this easily by leveraging **spring.config.activate.on-platform** property to apply specific configuration for Kubernetes.

```
---
spring:
  config:
    activate:
      on-cloud-platform: "kubernetes"
  cloud:
    kubernetes:
      discovery:
        enabled: true
      enabled: true
eureka:
  client:
    enabled: false
```

## 15: Refactor Premium Service Routing

### Plan Kubernetes Configuration

As you saw in the previous exercise, instances reported a hint to Eureka to indicate if they were **premium** or **nonpremium**, so we had this information on a per-instance basis, as shown below:

With Eureka:

- blueorgreen-app
  - blue (hint: nonpremium)
  - green (hint: nonpremium)
  - slowgreen (hint: nonpremium)
  - yellow (hint: premium)

With Kubernetes, we don't have this luxury, the metadata belongs to the **Service** so we can't define it on a per-instance (pod) basis:

On Kubernetes:

- blueorgreen-service (hint: premium or nonpremium?)
  - blue
  - green
  - slowgreen
  - yellow

How can we differentiate between premium and nonpremium instances on Kubernetes? One approach it so define the difference at the **Service** level, as follows:

On Kubernetes, with multiple Services:

- blueorgreen-nonpremium-service

  - blue
  - green
  - slowgreen

- blueorgreen-premium-service
  - blue
  - green
  - slowgreen
  - yellow

In order to route requests across the two Services, you need to modify the routing configuration in the Routing Gateway such that, if the incoming request belongs to a non-premium user, it is routed to the **blueorgreen-nonpremium Service**, and if the request belongs to a premium user, it is routed to the **blueorgreen-premium**.

### Update Routing Gateway

Notice the route definition in the Routing Gateway app for routing requests to the color instances:

> color-app/blueorgreengateway/src/main/java/org/springframework/demo/blueorgreengateway/BlueorgreengatewayApplication.java

`.route(p -> p.path("/blueorgreen")`

Replace this route definition with a different definition that distinguishes between premium and non-premium destinations. First, remove the existing route definition.

```
sed -i '29,31d' ~/color-app/blueorgreengateway/src/main/java/org/springframework/demo/blueorgreengateway/BlueorgreengatewayApplication.java
```

Notice the routes are now removed.

> color-app/blueorgreengateway/src/main/java/org/springframework/demo/blueorgreengateway/BlueorgreengatewayApplication.java

`return builder.routes()`

Then paste in the new route definitions.

> Note: If you indent the code appropriately in the editor, you will see the diff about the changes.

> color-app/blueorgreengateway/src/main/java/org/springframework/demo/blueorgreengateway/BlueorgreengatewayApplication.java

```
.route(p -> p.path("/blueorgreen")
        .and().header("X-SC-LB-Hint", "nonpremium")
        .filters(this::circuitBreaker)
        .uri("lb://blueorgreen-nonpremium"))
.route(p -> p.path("/blueorgreen")
        .filters(this::circuitBreaker)
        .uri("lb://blueorgreen-premium"))
```

The Routing Gateway will now be able to route requests appropriately without the help of Eureka hints.

## 16: Build Container Images

The next step is to package the applications as container images.

The apps cannot be deployed as plain .class or .jar files on Kubernetes. Instead, each application, along with all of its dependencies - including all Spring and other supporting libraries, the JRE, and the OS filesystem itself - must be packaged into a bundle that adheres to a standard format (Docker or OCI, which stands for Open Container Initiative). The container image is, hence, a standardized, complete, self-contained, immutable, executable bundle.

Container images provide operational simplicity because they alleviate the burden of having to prepare or maintain dependencies on the target runtime environment. They make applications easily portable across any runtime that supports Docker or OCI images, and they enable any configuration, such as environment variables, that should be constant across environments to be packaged into the application, hence providing opportunities to better secure the application.

There are several ways to build container images. In this exercise, you will use Cloud Native Buildpacks to generate an OCI image for each app.

Cloud Native Buildpacks (CNB, or buildpacks, for short) provides a standalone, standardized way to build OCI images. The images can then be published to any OCI-compliant container registry (e.g. Docker Hub, Harbor, etc...) and run on any OCI-compliant runtime platform (e.g. Kubernetes).

Spring Boot's maven plugin has built-in support for CNB through the **build-image** goal.

Build an image for each of the four Color Application apps.

> Note: To speed up the image builds, you can execute the following two action blocks concurrently. The action blocks will run in different terminal windows.

```
cd blueorgreenservice && ./mvnw spring-boot:build-image -D skipTests && cd ..
cd blueorgreenfrontend && ./mvnw spring-boot:build-image -D skipTests && cd ..
cd blueorgreengateway && ./mvnw spring-boot:build-image -D skipTests && cd ..
cd authgateway && ./mvnw spring-boot:build-image -D skipTests && cd ..
```

When the above commands have completed, list the images in your local Docker daemon.

`docker images`

Your output will look like this.

```
REPOSITORY                 TAG              IMAGE ID       CREATED        SIZE
paketobuildpacks/run       base-cnb         793c0420709a   5 days ago     87.7MB
paketobuildpacks/builder   base             bbb944e79519   41 years ago   590MB
blueorgreen                0.0.1-SNAPSHOT   231339643ceb   41 years ago   281MB
blueorgreengateway         0.0.1-SNAPSHOT   ad8cc4eda22c   41 years ago   316MB
blueorgreenfrontend        0.0.1-SNAPSHOT   823b34afdb3a   41 years ago   313MB
authgateway                0.0.1-SNAPSHOT   4f4ae4773596   41 years ago   316MB
```

## 17: Publish Images To Registry

In order to deploy these images to Kubernetes, Kubernetes must be able to "pull" them. Kubernetes cannot access them from the local Docker daemon. It can, however, pull them from a container registry that is network-accessible.

A local private container registry is available in this workshop environment. For convenience, its address is saved in an environment variable. You can see it by running the following command.

`echo $REGISTRY_HOST`

Publish the images to the container registry.

> Note: To speed up the publishing of images, you can execute the following two action blocks concurrently. The action blocks will run in different terminal windows.

```
docker tag blueorgreen:0.0.1-SNAPSHOT $REGISTRY_HOST/color-app/blueorgreenservice
docker push $REGISTRY_HOST/color-app/blueorgreenservice

docker tag blueorgreenfrontend:0.0.1-SNAPSHOT $REGISTRY_HOST/color-app/blueorgreenfrontend
docker push $REGISTRY_HOST/color-app/blueorgreenfrontend

docker tag blueorgreengateway:0.0.1-SNAPSHOT $REGISTRY_HOST/color-app/blueorgreengateway
docker push $REGISTRY_HOST/color-app/blueorgreengateway

docker tag authgateway:0.0.1-SNAPSHOT $REGISTRY_HOST/color-app/authgateway
docker push $REGISTRY_HOST/color-app/authgateway
```

You can use a CLI called skopeo to verify that the containers are in the registry. For example, check for the Backend container:

`skopeo list-tags docker://$REGISTRY_HOST/color-app/blueorgreenservice`

```
{
    "Repository": "eduk8s-labs-w01-s076-registry.s1tour-prod-c9040c6.tanzu-labs.esp.vmware.com/color-app/blueorgreenservice",
    "Tags": [
        "latest"
    ]
}
```

## 18: Inspect Images (OPTIONAL)

Spring Boot maven plugin is just one of several tools that support Cloud Native Buildpacks. Another example is a CLI called **pack**.

Spring Boot's maven and gradle plugins can be used to build applications built on Spring Boot 2.3.0 and above. For other Java applications, and for applications written in other languages such as Python, Node.js, Ruby, .NET, etc, you can use other tools. One example is a CLI called **pack**.

We do not need to rebuild our images. However, we can still use **pack** to leverage other features of CNB that are not available through the Spring Boot plugins.

For example, you can use **pack image inspect** to get information about an image, such as the base images and buildpacks used to create it.

`pack inspect blueorgreen:0.0.1-SNAPSHOT`

You can add a **--bom** ("bill of materials") flag to get more detailed information about the contents of the image, including - in this case - versions of the JRE and of all the Java dependencies.

`pack inspect blueorgreen:0.0.1-SNAPSHOT --bom`

Another neat inspection tool that works on any image, not just CNB-built images, is **dive**. This tool shows the contents of each layer of the image.

`dive blueorgreen:0.0.1-SNAPSHOT`

After running the command above use your keyboard to type: **Tab, Ctrl-U, Tab**

The **Tab** button is used to switch between the Layer and Filetree views. **Ctrl-U** is used in the Filetree view to hide/show unmodified files.

Use the down arrow to move down the list of layers on the left frame until you see the layers that have the dependencies (.jar files) and the app code (.class, .yml, etc files) on the right frame.

> Picture for reference of dependencies:alt_text

> Picture for reference of application-specific files:alt_text

Notice that there is no single fat jar. Rather, the Java application was exploded. This is an optimization to achieve faster startup time. Notice also that the exploded files are organized into multiple layers, separating files that change infrequently (e.g. Spring Boot base libraries) from files that change more frequently (e.g. your code). The layer that is most likely to change (application-specific .class files) is now kilobytes rather than megabytes. This makes it faster to rebuild images and publish images updates to container registries.

The precise intelligence for building the OCI image, including the optimizations above as well as others, don't come from the CNB project itself. Rather, they come from the set of Buildpacks that Spring Boot is using by default. These are the Paketo Buildpacks. You can learn more about the Paketo Java Buildpack here.

Exit **dive**.

`<ctrl+c>`

## 19: Create Deployment Manifests

Now that you have built and published the application images, you can attempt to deploy them to Kubernetes. Each image will be deployed using a Kubernetes **deployment** resource. The deployment creates one or more pods, each with a running instance of the image (aka a container) of the corresponding application. Each app will also need a Kubernetes **service** resource, which will load balance requests across all instances of a particular pod. The deployment and service resources will be defined declaratively using manifests (yaml files).

### Create Deployment Manifests

First, create the manifest for the **deployment** for the Frontend, Routing Gateway, and Auth Gateway. Use the **kubectl** CLI with the option `--dry-run=client` to generate the yaml without applying it to Kubernetes.

```
mkdir -p k8s

kubectl create deployment blueorgreenfrontend \
            --image $REGISTRY_HOST/color-app/blueorgreenfrontend \
            -o yaml --dry-run=client > k8s/frontend-deployment.yaml

kubectl create deployment blueorgreengateway \
            --image $REGISTRY_HOST/color-app/blueorgreengateway \
            -o yaml --dry-run=client > k8s/gateway-deployment.yaml

kubectl create deployment blueorgreenauthgateway \
            --image $REGISTRY_HOST/color-app/authgateway \
            -o yaml --dry-run=client > k8s/authgateway-deployment.yaml
```

### Create Deployment Manifest Template for Backend

Next, create the manifest for the **deployment** for the Backend. The command is exactly the same as the above commands, but in this you are saving the output of the command to a file with extension **.template** instead of **.yaml**. You will be converting this into 4 color-specific **yaml** files later in this exercise.

```
kubectl create deployment blueorgreen \
            --image $REGISTRY_HOST/color-app/blueorgreenservice \
            -o yaml --dry-run=client > k8s/blueorgreen-deployment.template
```

List all of the files you just created.

`ls -l k8s/`

Your output should look like this.

```
-rw-r--r-- 1 eduk8s root 539 May  7 01:47 authgateway-deployment.yaml
-rw-r--r-- 1 eduk8s root 509 May  7 01:47 blueorgreen-deployment.template
-rw-r--r-- 1 eduk8s root 543 May  7 01:47 frontend-deployment.yaml
-rw-r--r-- 1 eduk8s root 537 May  7 01:47 gateway-deployment.yaml
```

## 20: Mount Configuration - Frontend and Gateway Apps

Recall that in a previous step, you added configuration to the common **application.yml** file for Kubernetes deployments. Review the file now.

> color-app/config-files/application.yml
> `on-cloud-platform`

To maintain this configuration file external to the apps as in the original project setup, you can mount it as a ConfigMap. Spring Boot will then be able to access the file via a local path process it as it would on a local deployment.

Create a ConfigMap from the common **application.yml** file.

```
kubectl create configmap application-config \
        --from-file=config-files/application.yml \
        -o yaml --dry-run=client > k8s/application-configmap.yaml
```

Review the resulting file.

`cat k8s/application-configmap.yaml | yq eval`

Update each Deployment manifest in order to mount the ConfigMap as a volume mount on the app container.

Start with the Auth Gateway deployment manifest.

First create a volume.

> color-app/k8s/authgateway-deployment.yaml

```
volumes:
  - name: config-volume
    configMap:
      name: application-config
```

Then, mount the volume on the container. If you mount the volume at **/workspace/config/**, for example, Spring Boot will find this configuration by default and load it as usual. This is because Cloud Native Buildpacks places the app files in the **/workspace** directory in the image, and Spring Boot looks in **./config** for configuration files by default.

> color-app/k8s/authgateway-deployment.yaml

```
volumeMounts:
  - name: config-volume
    mountPath: /workspace/config
```

Do the same for the Routing Gateway and Frontend.

> color-app/k8s/gateway-deployment.yaml

```
volumes:
  - name: config-volume
    configMap:
      name: application-config
volumeMounts:
  - name: config-volume
    mountPath: /workspace/config
```

> color-app/k8s/frontend-deployment.yaml

```
volumes:
  - name: config-volume
    configMap:
      name: application-config
volumeMounts:
  - name: config-volume
    mountPath: /workspace/config
```

For the above three apps, you only need to mount the **application.yml** file configuration. The app-specific config files were used only to set unique ports, which is not necessary on Kubernetes.

For the Backend, however, you do need to mount the application-specific config file as well.

In the next step, you will mount configuration for the Backend app.

## 21: Mount Configuration - Backend

The Backend will use the same ConfigMap as the other apps, but it also has additional configuration specified in the application-specific file. Take a moment to review this file.

These configurations will cause each app to start on a different port when run locally. On Kubernetes, this is not necessary, and in fact would only complicate configuration management. You can remove the **server.port** settings from this file, or you can set the ports to 8080 on Kubernetes. The latter approach maintains back-compatibility with non-cloud deployments.

Add configuration to set the port to 8080 on Kubernetes:

> color-app/config-files/blueorgreen.yml

```
---
spring:
  config:
    activate:
      on-cloud-platform: "kubernetes"
server:
  port: 8080
```

Creating a ConfigMap from **blueorgreen.yml**.

```
kubectl create configmap blueorgreen-config \
        --from-file=application-blueorgreen.yml=config-files/blueorgreen.yml \
        -o yaml --dry-run=client > k8s/blueorgreen-configmap.yaml
```

Review the resulting file. Notice in particular that, in generating the ConfigMap, you "renamed" the file from **blueorgreen.yml** to **application-blueorgreen.yml**.

> color-app/k8s/blueorgreen-configmap.yaml

Why rename the file in this situation? Spring Cloud Config Server automatically detects files named **\<appName>-\<profile>.yml** and takes care of the order of precedence when applying these over **application-\<profile>.yml**. Spring Boot, on the other hand, only automatically detects files names as **application-\<profile>.yml**. Since this deployment will not include Spring Cloud Config Server, you can rename **blueorgreen.yml** to **application-blueorgreen.yml** and set **blueorgreen** as an additional profile for the Backend service. This will enable Spring Boot to process both mounted files, **application.yml** and **application-blueorgreen.yml** as expected.

Mount both ConfigMaps as VolumeMounts on the Backend container.

> color-app/k8s/blueorgreen-deployment.template

```
volumes:
  - name: config-volume
    projected:
      sources:
        - configMap:
            name: application-config
        - configMap:
            name: blueorgreen-config
volumeMounts:
  - name: config-volume
    mountPath: /workspace/config
```

## 22: Liveness & Readiness Probes

It is good practice to add liveness and readiness probes to your Deployments. Liveness probes tell Kubernetes that the app is up. Readiness probes tell Kubernetes that the app is ready to receive traffic.

Add liveness and readiness probes to all Deployment manifests.

> color-app/k8s/blueorgreen-deployment.template

```
readinessProbe:
  initialDelaySeconds: 30
  httpGet:
    port: 8080
    path: /actuator/health/readiness
livenessProbe:
  initialDelaySeconds: 30
  httpGet:
    port: 8080
    path: /actuator/health/liveness
```

> color-app/k8s/frontend-deployment.yaml

```
readinessProbe:
  initialDelaySeconds: 30
  httpGet:
    port: 8080
    path: /actuator/health/readiness
livenessProbe:
  initialDelaySeconds: 30
  httpGet:
    port: 8080
    path: /actuator/health/liveness
```

> color-app/k8s/gateway-deployment.yaml

```
readinessProbe:
  initialDelaySeconds: 30
  httpGet:
    port: 8080
    path: /actuator/health/readiness
livenessProbe:
  initialDelaySeconds: 30
  httpGet:
    port: 8080
    path: /actuator/health/liveness
```

> color-app/k8s/authgateway-deployment.yaml

```
readinessProbe:
  initialDelaySeconds: 30
  httpGet:
    port: 8080
    path: /actuator/health/readiness
livenessProbe:
  initialDelaySeconds: 30
  httpGet:
    port: 8080
    path: /actuator/health/liveness
```

## 23: Templating The Backend Deployment

The file blueorgreen-deployment.template will act as a template for creating deployment manifests for the various Color Apps. We need to template this deployment manifest in two places:

1. The name of the deployment
2. The Spring Boot profile to activate

### Template Deployment Name

Execute the following **sed** command to replace the **metadata.name** property in the manifest with the template $COLOR.

`sed -i '0,/name: blueorgreen/{s/name: blueorgreen/name: $COLOR/}' k8s/blueorgreen-deployment.template`

### Template Spring Boot Active Profiles

To activate the Spring Boot profile for the color you can set the environment variable **SPRING_PROFILES_ACTIVE** in the container when it starts on Kubernetes.

> Note: Recall that in a previous step you defined the ConfigMap for **blueorgreen.yml** as **application-blueorgreen.yml**. To ensure Spring Boot processes this file, you need to add **blueorgreen** to the list of active profiles.

Add the following templated environment variable to the manifest to set the active profiles.

> color-app/k8s/blueorgreen-deployment.template

```
env:
  - name: SPRING_PROFILES_ACTIVE
    value: 'blueorgreen,$COLOR'
```

## Template Premium/Nonpremium Hints

Add a label to the deployments called **hint** indicating whether a service is premium. This will also need to be templated so that it can be set differently for different color instances.

> Note: You will use this hint when creating the Kubernetes Services in the next step.

> color-app/k8s/blueorgreen-deployment.template

```
hint: $TYPE
hint: $TYPE
hint: $TYPE
```

## Generate Deployment Manifests From Template

Now we can substitute the variables in this template using the **envsubst** command line utility and generate deployment manifests for each of the Color Apps.

```
COLOR=blue
TYPE=nonpremium
export COLOR
export TYPE
envsubst < k8s/blueorgreen-deployment.template > k8s/blue-deployment.yaml

COLOR=green
TYPE=nonpremium
export COLOR
export TYPE
envsubst < k8s/blueorgreen-deployment.template > k8s/green-deployment.yaml

COLOR=yellow
TYPE=premium
export COLOR
export TYPE
envsubst < k8s/blueorgreen-deployment.template > k8s/yellow-deployment.yaml

COLOR=slowgreen
TYPE=nonpremium
export COLOR
export TYPE
envsubst < k8s/blueorgreen-deployment.template > k8s/slowgreen-deployment.yaml
```

List the deployment manifest files you have created.

`ls -l k8s/ | grep deployment.yaml`

The output will look like this.

```
-rw-r--r-- 1 eduk8s root 1028 May 11 19:13 authgateway-deployment.yaml
-rw-r--r-- 1 eduk8s root 1276 May 11 19:14 blue-deployment.yaml
-rw-r--r-- 1 eduk8s root 1032 May 11 19:13 frontend-deployment.yaml
-rw-r--r-- 1 eduk8s root 1026 May 11 19:13 gateway-deployment.yaml
-rw-r--r-- 1 eduk8s root 1278 May 11 19:14 green-deployment.yaml
-rw-r--r-- 1 eduk8s root 1286 May 11 19:14 slowgreen-deployment.yaml
-rw-r--r-- 1 eduk8s root 1271 May 11 19:14 yellow-deployment.yaml
```

Take a moment to review one of the files created. For example, in the following file, $COLOR was replace by blue, an $TYPE was replaced by nonpremium.

> color-app/k8s/blue-deployment.yaml

## 24: Create Service Manifests

### Create Frontend And Gateway Services

Use the "dry-run" approach that you used for Deployment manifests to create Service manifests without applying them to Kubernetes.

```
kubectl create service clusterip blueorgreenfrontend \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/frontend-service.yaml

kubectl create service clusterip blueorgreengateway \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/gateway-service.yaml

kubectl create service clusterip blueorgreenauthgateway \
            --tcp 80:8080 \
            -o yaml --dry-run=client > k8s/authgateway-service.yaml
```

### Create Backend Services

For the Backend apps, you need to create two services: premium and non-premium. For simplicity, we have supplied the entire service definitions as opposed to using **kubectl** to create them. Click the action item below to create the two service definitions for the Backend app.

> color-app/k8s/blueorgreen-service.yaml

```
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  labels:
    app: blueorgreen
    hint: nonpremium
  name: blueorgreen-nonpremium
spec:
  ports:
  - name: 80-8080
    port: 80
    protocol: TCP
    targetPort: 8080
  selector:
    app: blueorgreen
    hint: nonpremium
  type: ClusterIP
status:
  loadBalancer: {}
---
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  labels:
    app: blueorgreen
    hint: premium
  name: blueorgreen-premium
spec:
  ports:
  - name: 80-8080
    port: 80
    protocol: TCP
    targetPort: 8080
  selector:
    app: blueorgreen
  type: ClusterIP
status:
  loadBalancer: {}
```

List the service manifest files you just created.

`ls -l k8s/ | grep service`

The output will look like this.

```
-rw-r--r-- 1 eduk8s root  312 May 11 19:16 authgateway-service.yaml
-rw-r--r-- 1 eduk8s root  641 May 11 19:16 blueorgreen-service.yaml
-rw-r--r-- 1 eduk8s root  303 May 11 19:16 frontend-service.yaml
-rw-r--r-- 1 eduk8s root  300 May 11 19:16 gateway-service.yaml
```

## 25: Create An Ingress For The Auth Gateway

In order to access the Auth Gateway from a browser, you must expose the Auth Gateway Service via an Ingress. Create an Ingress using the following action.

> color-app/k8s/authgateway-ingress.yaml

```
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: blueorgreenauthgateway
  labels:
    app: blueorgreenauthgateway
spec:
  rules:
  - host: blueorgreenauthgateway-eduk8s-labs-w01-s076.s1tour-prod-c9040c6.tanzu-labs.esp.vmware.com
    http:
      paths:
      - path: "/"
        pathType: Prefix
        backend:
          service:
            name: blueorgreenauthgateway
            port:
              number: 80
```

## 26: Deploy And Test The Application

Now you are ready to deploy the Color Application to Kubernetes.

To **watch** the deployment as it happens, run the following command.

> Note: The command will execute in Terminal 2. Initially you will see the output: **No resources found in springone-tour-lab-workshop-2-w01-s001 namespace**. Let the command continue to run and proceed to the next action block. The output in Terminal 2 will change as the deployment progresses.

`watch -n 1 kubectl get all`

To deploy everything to Kubernetes run the following command

`kubectl apply -Rf ~/color-app/k8s`

Wait until **STATUS=Ready** and **READY=1/1** for all pods. Then, click the action button below to open the Auth Gateway in your browser and test the application. You should be able to log in with the user **user** and the password **pw** and only see the colors blue, green, or red (for the slowgreen service.)

http://blueorgreenauthgateway-eduk8s-labs-w01-s076.s1tour-prod-c9040c6.tanzu-labs.esp.vmware.com

Now log out by going to

http://blueorgreenauthgateway-eduk8s-labs-w01-s076.s1tour-prod-c9040c6.tanzu-labs.esp.vmware.com/logout

Then log back in with the user **premium** and the password **pw**. Now in addition to the colors you saw with the user **user** you should see the color yellow.

Exit the watch command by running the following action command.

`<ctrl+c>`

### Next Steps

You are ready to begin the third and last lab of this workshop: re-deploy the application to Kubernetes without Spring Cloud Kubernetes.

## 27: Lab 3 - Deploy To Kubernetes Without Spring Cloud Kubernetes

Spring Cloud provides nice abstractions around things like load balancing, service discovery, and configuration that allows you to run your applications on multiple cloud platforms with little to no changes of the code base.

If, however, you have determined you only want to deploy your applications to Kubernetes and don't want or need the abstractions, you can rely on the cloud native features of Kubernetes directly in which case you can remove Spring Cloud Kubernetes from your applications.

Over the following few sections, you will re-deploy the Color Application to Kubernetes using Kubernetes directly for service discovery and load balancing, including:

- Remove Spring Cloud Kubernetes Dependencies
- Remove Spring Cloud LoadBalancer
- Rebuild and Redeploy
- Test The Applications

## 28: Remove Spring Cloud Kubernetes Dependencies

Execute the following sed commands to remove the Spring Cloud Kubernetes dependencies from the application POM files.

```
sed -i '29,36d' ~/color-app/authgateway/pom.xml
sed -i '29,36d' ~/color-app/blueorgreengateway/pom.xml
sed -i '29,36d' ~/color-app/blueorgreenfrontend/pom.xml
```

## 29: Remove Spring Cloud LoadBalancer

The Frontend, Auth Gateway, and Routing Gateway apps use Spring load balanced routes and Rest templates to load balance requests across endpoints. On Kubernetes, this is redundant since Kubernetes Services provide load balancing across pods.

The Auth Gateway uses the lb protocol. Use the following action button to view the line where it is used.

> color-app/authgateway/src/main/java/org/springframework/cloud/samples/authgateway/AuthgatewayApplication.java

`lb://blueorgreengateway`

Execute the following command to replace the lb protocol with http.

```
sed -i s/lb:/http:/g ~/color-app/authgateway/src/main/java/org/springframework/cloud/samples/authgateway/AuthgatewayApplication.java
```

Check the file again to verify that the protocol has been updated.

`http://blueorgreengateway`

The Frontend uses a **@LoadBalanced RestTemplate**. Use the following action button to view the line where it is used.

`@LoadBalanced`

Execute the following command to remove the @LoadBalanced annotation.

```
sed -i s/@LoadBalanced//g ~/color-app/blueorgreenfrontend/src/main/java/org/springframework/demo/BlueOrGreenFrontendApplication.java
```

Click on the Editor tab again and validate that the annotation was deleted.

The Routing Gateway also uses load balanced routes. Use the following action buttons to view the lines where they are used.

```
lb://blueorgreen-nonpremium
lb://blueorgreen-premium
lb://blueorgreenfrontend
```

Execute the following command to replace the lb protocol with http.

```
sed -i s/lb:/http:/g ~/color-app/blueorgreengateway/src/main/java/org/springframework/demo/blueorgreengateway/BlueorgreengatewayApplication.java
```

Click on the Editor tab again and validate that the protocol was updated in all three locations.

In addition, Auth Gateway uses a **@LoadBalancerClient** annotation that is no longer needed.

> color-app/blueorgreengateway/src/main/java/org/springframework/demo/blueorgreengateway/BlueorgreengatewayApplication.java

`@LoadBalancerClient`

Execute the following command to remove the @LoadBalancerClient annotation.

```
sed -i '19,19d' ~/color-app/blueorgreengateway/src/main/java/org/springframework/demo/blueorgreengateway/BlueorgreengatewayApplication.java
sed -i '9,9d' ~/color-app/blueorgreengateway/src/main/java/org/springframework/demo/blueorgreengateway/BlueorgreengatewayApplication.java
```

Since you no longer need any load balancer client configuration you can also remove the **LoadBalancerConfiguration.java** file entirely.

```
rm ~/color-app/blueorgreengateway/src/main/java/org/springframework/demo/blueorgreengateway/LoadBalancerConfiguration.java
```

## 30: Rebuild and Redeploy The Application

Now that you have removed all the code, you can re-build the images, push them to the registry, and redeploy the applications.

Remove the deployments and services from Kubernetes using the following command.

`kubectl delete -Rf ~/color-app/k8s`

Build new images for the apps using the following command.

```
cd blueorgreenfrontend/ && ./mvnw spring-boot:build-image -D skipTests && cd ../
cd blueorgreengateway/ && ./mvnw spring-boot:build-image -D skipTests && cd ../
cd authgateway/ && ./mvnw spring-boot:build-image -D skipTests && cd ../
```

Push the new images to the registry using the following command.

```
docker tag blueorgreenfrontend:0.0.1-SNAPSHOT $REGISTRY_HOST/color-app/blueorgreenfrontend
docker push $REGISTRY_HOST/color-app/blueorgreenfrontend

docker tag blueorgreengateway:0.0.1-SNAPSHOT $REGISTRY_HOST/color-app/blueorgreengateway
docker push $REGISTRY_HOST/color-app/blueorgreengateway

docker tag authgateway:0.0.1-SNAPSHOT $REGISTRY_HOST/color-app/authgateway
docker push $REGISTRY_HOST/color-app/authgateway
```

To **watch** the deployments happen run the following command

`watch -n 1 kubectl get all`

Deploy the updated images.

`kubectl apply -Rf ~/color-app/k8s`

Once **STATUS=Ready** and **READY=1/1** for all pods, exit the watch command.

`<ctrl+c>`

## 31: Test The Application

You can open the Auth Gateway and test out the premium and non-premium use cases.

Premium username: **premium** Premium password: **pw**

Non-premium username: **user** Non-premium password: **pw**

Use the following action button to open the Auth Gateway in your browser.

http://blueorgreenauthgateway-eduk8s-labs-w01-s076.s1tour-prod-c9040c6.tanzu-labs.esp.vmware.com

You can use the following action button to log out.

http://blueorgreenauthgateway-eduk8s-labs-w01-s076.s1tour-prod-c9040c6.tanzu-labs.esp.vmware.com/logout

If you refresh the app in your browser you will likely see the same color returned every time you refresh.

Load balancing is very "sticky" with Kubernetes services. If you make a lot of requests, you will eventually notice the load balancing. An easy way to demonstrate this is to run a script that generates many requests. You can execute this script within a pod on Kubernetes.

Execute the following command to run a pod that will open a **bash** terminal allowing you to run some commands inside the pod.

`kubectl run --rm utils -it --image yenigul/dockernettools bash`

After a few moments, you should see the following output in Terminal 2:

> If you don't see a command prompt, try pressing enter.

`bash-5.0$ `

Once you see the **bash** prompt, run the following command to make several hundred requests to the Routing Gateway. Observe the colors returned.

`x=1; while [ $x -le 500 ]; do curl http://blueorgreengateway/blueorgreen; (( x++ )); done`

As this runs, you should see the color change every so often.

Exit the running pod by executing the following command.

`exit`

# 32: Conclusion

During this workshop you moved an application comprising 4 Spring Boot apps to Kubernetes, including:

- Test the app locally to understand its behavior
  - Use Eureka for discovery
  - Use Spring Cloud Config Server for configuration
- Move the apps to Kubernetes
  - Use Spring Cloud Kubernetes for discovery
  - Use Kubernetes ConfigMaps for configuration
  - Create required Kubernetes resources (deployments, services, configmaps, ingress)
- Redeploy the apps to Kubernetes
  - Use Kubernetes natively for discovery (remove Spring Cloud Kubernetes)
